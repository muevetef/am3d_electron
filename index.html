<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no,  minimal-ui"
    />
    <title>Ametlles 3d</title>
    <script src="build/jquery-3.4.1.js"></script>
    <script src="build/three.js"></script>
    <script src="js/controls/OrbitControls.js"></script>
    <script src="js/QuickHull.js"></script>
    <script src="js/geometries/ConvexGeometry.js"></script>
    <script src="js/WebGL.js"></script>
    <script src="js/libs/stats.min.js"></script>
    <script src="js/loaders/STLLoader.js"></script>
    <script src="js/exporters/STLExporter.js"></script>
    <script src="js/calculate.js"></script>

    <link rel="stylesheet" type="text/css" href="css/style.css" />
    <link
      rel="stylesheet"
      type="text/css"
      href="css/fontawesome/css/all.min.css"
    />
  </head>
  <style></style>

  <body>
    <div id="loader">
      <div id="spinner"></div>
      <p>Carregant...</p>
    </div>
    <div id="menuBar" class="navbar">
      <ul>
        <li>
          <label for="pickFile" title="Selecciona un model">
            <i class="fas fa-folder-open"></i>
          </label>
          <input type="file" class="hide" id="pickFile" multiple />
        </li>
        <li>
          <label for="nextFile" title="model seguent">
            <i class="fas fa-arrow-right disabled"></i>
          </label>
          <input type="button" class="hide" id="nextFile" />
        </li>

        <li>
          <label for="resetMarkers" title="Reiniciar Marcadors">
            <i class="fas fa-eraser disabled"></i>
          </label>
          <input type="button" class="hide" id="resetMarkers" />
        </li>
        <li>
          <label for="guardar" alt="Selecciona un model">
            <i class="fas fa-save disabled"></i>
          </label>
          <input type="button" class="hide" id="guardar" />
        </li>
        <li>
          <label for="projection" title="Projection">
            <i class="fas fa-eraser"></i>
          </label>
          <input type="button" class="hide" id="projection" />
        </li>
      </ul>
    </div>
    <div id="wrapper">
      <div id="container"></div>
      <div id="layers">
        <fieldset class="proj">
          <legend>Top</legend>
          <canvas id="projTop" width="200" height="200"></canvas>
        </fieldset>
        <fieldset class="proj">
          <legend>Bottom</legend>
          <canvas id="projBottom" width="200" height="200"></canvas>
        </fieldset>
        <fieldset class="proj">
          <legend>Front</legend>
          <canvas id="projFront" width="200" height="200"></canvas>
        </fieldset>
        <fieldset class="proj">
          <legend>Back</legend>
          <canvas id="projBack" width="200" height="200"></canvas>
        </fieldset>
        <fieldset class="proj">
          <legend>Left</legend>
          <canvas id="projLeft" width="200" height="200"></canvas>
        </fieldset>
        <fieldset class="proj">
          <legend>Right</legend>
          <canvas id="projRight" width="200" height="200"></canvas>
        </fieldset>
      </div>
    </div>
    <div id="console"></div>
    <script>
      // Define a global variable 'Module' with a method 'onRuntimeInitialized':

      const cv = require("./js/opencv.js");
      const Jimp = require("jimp");
      var scene, camera, renderer, controls;
      var w = window.innerWidth;
      var h = window.innerHeight;

      var topCamera,
        bottomCamera,
        frontCamera,
        backCamera,
        rightCamera,
        leftCamera;
      var ortoCamSize = 30;

      var files;
      var currentFile = 0;

      var btNextFile = document.getElementById("nextFile");

      btNextFile.addEventListener("click", processModels);

      var btInput = document.getElementById("pickFile");
      btInput.addEventListener("change", openFile, false);

      var btResetMarkers = document.getElementById("resetMarkers");
      btResetMarkers.addEventListener("click", resetMarkers);

      var btGuardar = document.getElementById("guardar");
      btGuardar.addEventListener("click", guardar);

      var btGuardar = document.getElementById("projection");
      //btGuardar.addEventListener("click", setProjectionContour);

      var model = {
        mesh: null,
        markers: [],
        boxHelper: null,
        bufferGeometry: null,
        bBox: null,
        projections: {
          top: null,
          bottom: null,
          front: null,
          back: null,
          left: null,
          right: null,
        },
      };

      function init() {
        initScene();
        initCameras();
       
        initControls();
        initGrid();
        initModel();
      }

      var fs = require("fs");
      const path = require("path");
      var remote = require("electron").remote;

      var dialog = require("electron").remote.dialog;

      var app = require("electron").remote.app;

      var docsDir = app.getPath("documents") + "/Am3D/models/";

      const imgDir = app.getPath("documents") + "/Am3D/img/";

      init();

      function initScene() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color("#000000");

        //initialice renderer................................................
        renderer = new THREE.WebGLRenderer({
          antialias: true,
        });

        renderer.setSize(w, h);
        container.appendChild(renderer.domElement);

        if (!fs.existsSync(docsDir)) {
          fs.mkdir(docsDir, { recursive: true }, function (err) {
            if (err) {
              console.log(err);
            } else {
              console.log("Folder " + docsDir + " created!");
            }
          });
        } else {
          console.log("Folder " + docsDir + " exists");
        }
      }

      function initModel() {
        if (!model.mesh) {
          model.mesh = new THREE.Mesh();
/*           model.mesh.material = new THREE.MeshLambertMaterial({
            color: 0xffffff,
          }); */
          model.mesh.material.color.setHex( 0xffffff );
        }
      }

      function initCameras() {
        //initialize cameras................................................
        camera = new THREE.PerspectiveCamera(30, w / h, 1, 1000);
        camera.position.set(0, 60, 120);

        topCamera = new THREE.OrthographicCamera(
          -ortoCamSize,
          ortoCamSize,
          ortoCamSize,
          -ortoCamSize,
          10,
          2000
        );
        topCamera.position.set(0, 80, 0);
        topCamera.up.set(0, 0, -1);
        topCamera.lookAt(new THREE.Vector3(0, 0, 0));
        topCamera.layers.set(1);

        bottomCamera = new THREE.OrthographicCamera(
          -ortoCamSize,
          ortoCamSize,
          ortoCamSize,
          -ortoCamSize,
          10,
          2000
        );
        bottomCamera.position.set(0, 80, 0);
        bottomCamera.up.set(0, 0, -1);
        bottomCamera.lookAt(new THREE.Vector3(0, 0, 0));
        bottomCamera.layers.set(2);

        frontCamera = new THREE.OrthographicCamera(
          -ortoCamSize,
          ortoCamSize,
          ortoCamSize,
          -ortoCamSize,
          10,
          2000
        );
        frontCamera.position.set(0, 0, 80);
        frontCamera.up.set(0, 1, 0);
        frontCamera.lookAt(new THREE.Vector3(0, 0, 0));
        frontCamera.layers.set(3);

        backCamera = new THREE.OrthographicCamera(
          -ortoCamSize,
          ortoCamSize,
          ortoCamSize,
          -ortoCamSize,
          10,
          2000
        );
        backCamera.position.set(0, 0, 80);
        backCamera.up.set(0, 1, 0);
        backCamera.lookAt(new THREE.Vector3(0, 0, 0));
        backCamera.layers.set(4);

        leftCamera = new THREE.OrthographicCamera(
          -ortoCamSize,
          ortoCamSize,
          ortoCamSize,
          -ortoCamSize,
          10,
          2000
        );
        leftCamera.position.set(-80, 0, 0);
        leftCamera.up.set(0, 1, 0);
        leftCamera.lookAt(new THREE.Vector3(0, 0, 0));
        leftCamera.layers.set(5);

        rightCamera = new THREE.OrthographicCamera(
          -ortoCamSize,
          ortoCamSize,
          ortoCamSize,
          -ortoCamSize,
          10,
          2000
        );
        rightCamera.position.set(80, 0, 0);
        rightCamera.up.set(0, 1, 0);
        rightCamera.lookAt(new THREE.Vector3(0, 0, 0));
        rightCamera.layers.set(6);
      }

      
      function initControls() {
        //init controls................................................
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enablePan = false;
        controls.addEventListener("change", render);
      }

      function initGrid() {
        //show grid................................................
        var size = 80;
        var divisions = 10;

        var gridHelper = new THREE.GridHelper(size, divisions);
        scene.add(gridHelper);

        var axesHelper = new THREE.AxesHelper(100);
        scene.add(axesHelper);
        render();
      }

      //render function................................................
      function render() {
        renderer.render(scene, camera);
      }

      //function openfile................................................
      function openFile(evt) {
        // files = evt.target.files;
        // currentFile = 0;
        // setModel();
      }

      let stlFiles = [];

      const getFilesRecursively = (directory) => {
        const filesInDirectory = fs.readdirSync(directory);
        for (const file of filesInDirectory) {
          const absolute = path.join(directory, file);
          if (fs.statSync(absolute).isDirectory()) {
            getFilesRecursively(absolute);
          } else {
            if (path.extname(absolute) === ".stl") stlFiles.push(absolute);
          }
        }
      };
      getFilesRecursively(app.getPath("documents"));
      console.log(stlFiles);

      function toArrayBuffer(buf) {
        const ab = new ArrayBuffer(buf.length);
        const view = new Uint8Array(ab);
        for (let i = 0; i < buf.length; ++i) {
          view[i] = buf[i];
        }
        return ab;
      }

      function readModel(path) {
        console.log(path);
        console.time("load");
        const buff = fs.readFileSync(path);

        const arrayBuff = toArrayBuffer(buff);

        const loader = new THREE.STLLoader();
        // parse the .stl file

        model.mesh.geometry = loader.parse(arrayBuff); //or buff.buffer
        model.mesh.geometry.computeBoundingBox();

        model.mesh.layers.enable(1);
        model.mesh.layers.enable(2);
        model.mesh.layers.enable(3);
        model.mesh.layers.enable(4);
        model.mesh.layers.enable(5);
        model.mesh.layers.enable(6);

        model.mesh.name = "ametlla";
        scene.add(model.mesh);

        console.log("Model " + model.name + " carregat.");

        render();

        console.log(model.name);
        console.timeEnd("load");
      }

      

      function resetCamera() {
        w = window.innerWidth;
        h = window.innerHeight;
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
        renderer.setSize(w, h);
        render();
      }

      window.addEventListener("resize", onWindowResize, false);

      function onWindowResize() {
        resetCamera();
      }
     
      let modelCounter = 0;

      function processModels() {
        if (modelCounter < stlFiles.length) {
          model.name = path.basename(stlFiles[modelCounter]);
          readModel(stlFiles[modelCounter]);
          setViews(model.mesh);
          scene.remove(model.mesh);
          model.mesh.geometry.dispose();
          console.log("model counter: "+ (modelCounter + 1) +"..................................................");
          modelCounter++;

          processModels();
        }
      }

      function setViews(mesh) {
        console.time("img");
        var c = new THREE.Vector3();
        var f = mesh.geometry.boundingBox.getCenter(c);
        //console.log(c);
        topCamera.lookAt(c);
        topCamera.updateProjectionMatrix();

        bottomCamera.lookAt(c);
        bottomCamera.updateProjectionMatrix(); 

        frontCamera.lookAt(c);
        frontCamera.updateProjectionMatrix();

        backCamera.lookAt(c);
        backCamera.updateProjectionMatrix();

        leftCamera.lookAt(c);
        leftCamera.updateProjectionMatrix();

        rightCamera.lookAt(c);
        rightCamera.updateProjectionMatrix();

        renderer.setSize(1024, 1024);

        renderer.render(scene, topCamera);
        saveprojections(renderer.domElement.toDataURL(), "top");

        renderer.render(scene, bottomCamera);
        saveprojections(renderer.domElement.toDataURL(), "bottom");

        renderer.render(scene, frontCamera);
        saveprojections(renderer.domElement.toDataURL(), "left");

        renderer.render(scene, backCamera);
        saveprojections(renderer.domElement.toDataURL(), "right");

        renderer.render(scene, leftCamera);
        saveprojections(renderer.domElement.toDataURL(), "front");

        renderer.render(scene, rightCamera);
        saveprojections(renderer.domElement.toDataURL(), "back"); 

        console.timeEnd("img");
      }

      function saveprojections(src, type) {
        var fileName = model.name.substr(0, model.name.lastIndexOf("."));
        var fileDirArr = model.name.split("_");
        var fileDirName = fileDirArr[0] + "/";

        // With checking if dir already exists
        const dir = imgDir + "/" + type + "/" + fileDirName;

        if (!fs.existsSync(dir)) {
          fs.mkdirSync(dir, { recursive: true });
        }
        var filePath = dir + fileName + "_" + type + ".png";
        console.log(filePath);

        let base64Image = src.split(";base64,").pop();
        const buffer = Buffer.from(base64Image, "base64");

        fs.writeFileSync(filePath, buffer);
      }


    </script>
  </body>
</html>
